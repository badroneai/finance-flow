# طلبات الإصلاحات

ضع هنا قائمة الإصلاحات أو التعديلات التي تريد تنفيذها. اكتب كل طلب بشكل واضح (مرقّم إن أردت)، ثم احفظ الملف وأخبرني لقراءته والبدء بالتنفيذ.

---

## الطلبات

(اكتب طلباتك أدناه)

---

### ملاحظة معلقة (متابعة لاحقاً)
- **لوحة التحكم — الجدول الإحصائي (الرسم البياني):** الأرقام الحالية/الموجودة أصلاً (بيانات البذور التي تم وضعها) لا تنعكس على الرسم. أي رقم جديد يُضاف ينعكس بشكل صحيح. يُرجع معالجتها لاحقاً.

---

الآن ندخل المرحلة الثانية: **تحسينات الجودة والجاهزية للإنتاج**. هذي كل البرومبتات مقسمة كدفعات:

---

## الخطوة 10: إصلاح bug الرسم البياني + تنظيف الملفات المكررة

```
# المهمة: إصلاح bug رسم لوحة التحكم + تنظيف ملفات مكررة

## ⚠️ قواعد:
- لا تحذف ملفات أساسية — فقط ملفات مكررة أو غير مستخدمة
- بعد الانتهاء شغّل `npm run build` وتأكد من النجاح

## المطلوب:

### 1. إصلاح bug الرسم البياني في DashboardPage
في src/pages/DashboardPage.jsx (أو حيث يوجد DashboardPage):
- ابحث عن useMemo الذي يحسب chartData
- المشكلة: الـ dependency array فارغ `[]` مما يعني أن الرسم لا يتحدث عند إضافة حركات جديدة
- الحل: أضف التبعيات الصحيحة (مثل transactions أو filteredTransactions أو أي state يؤثر على البيانات) إلى الـ dependency array
- تأكد أن الرسم يُحدَّث عند تغيير الفترة (period) أيضاً

### 2. تنظيف الملفات المكررة والقديمة
افحص المشروع وحدد:

أ) **assets/ vs public/assets/:**
- ابحث عن أي ملف في `assets/` له نسخة مطابقة في `public/assets/`
- حدد أي النسختين هي المستخدمة فعلياً في الاستيرادات
- احذف النسخة غير المستخدمة
- إذا كان `assets/js/bootstrap.js` يعيد التصدير فقط من `public/assets/`، احذفه واستبدل استيراداته بالمسار المباشر

ب) **ملف format.js المحذوف:**
- تأكد أنه لا يوجد ملف `src/utils/format.js` (نسخة قديمة من format.jsx) — إذا وُجد احذفه

ج) **Dead code:**
- ابحث عن أي دوال أو متغيرات مُعرّفة لكنها غير مستخدمة في أي مكان
- ابحث عن أي imports غير مستخدمة
- أزل ما تجده مع توثيق ما أزلته

د) **SIMULATE_RENDER_ERROR:**
- إذا وجدت ثابت SIMULATE_RENDER_ERROR في App.jsx أو أي ملف آخر، تأكد أن قيمته false وأنه مخصص فقط للتطوير
- أضف تعليقاً واضحاً أنه للتطوير فقط

### 3. تقرير التنظيف
أعطني:
- قائمة بالملفات المحذوفة مع السبب
- قائمة بالـ dead code المُزال
- قائمة بالاستيرادات المصححة
- نتيجة npm run build
```

---

## الخطوة 11: إضافة React Router

```
# المهمة: إضافة React Router للتطبيق

## ⚠️ قواعد:
- لا تغيّر شكل أو تصميم التطبيق — فقط أضف التوجيه عبر URL
- يجب أن يعمل زر "رجوع" في المتصفح بعد التعديل
- بعد الانتهاء شغّل `npm run build`

## السياق:
التطبيق حالياً يستخدم state (page/setPage) للتنقل بين الصفحات. لا يوجد React Router. هذا يعني:
- المستخدم لا يستطيع استخدام زر "رجوع"
- لا يمكن مشاركة رابط لصفحة محددة
- عند تحديث الصفحة يرجع للرئيسية دائماً

## المطلوب:

### 1. تثبيت react-router-dom
```
npm install react-router-dom
```

### 2. إنشاء src/router.jsx
أنشئ ملف التوجيه مع المسارات التالية:

| المسار (Path) | المكون | ملاحظات |
|--------------|--------|---------|
| `/` | HomePage | الصفحة الرئيسية |
| `/dashboard` | DashboardPage | لوحة التحكم |
| `/transactions` | TransactionsPage | الحركات المالية |
| `/commissions` | CommissionsPage | العمولات |
| `/ledgers` | LedgersPage | الدفاتر |
| `/templates` | TemplatesPage | قوالب الخطابات |
| `/generator` | GeneratorPage | إنشاء خطاب |
| `/drafts` | DraftsPage | المسودات |
| `/calendar` | NotesCalendar (mode=calendar) | التقويم |
| `/notes` | NotesCalendar (mode=notes) | الملاحظات |
| `/settings` | SettingsPage | الإعدادات |
| `*` | إعادة توجيه إلى `/` | أي مسار غير معروف |

### 3. تعديل App.jsx
- أزل useState لـ page و setPage
- أزل دالة renderPage
- استخدم <Routes> و <Route> من react-router-dom
- استبدل setPage('xxx') بـ useNavigate() → navigate('/xxx')
- استبدل page === 'xxx' بـ useLocation() إذا لزم

### 4. تعديل Sidebar.jsx
- استبدل onClick={() => setPage(id)} بـ <NavLink to={`/${id}`}> أو useNavigate
- أضف active class بناءً على المسار الحالي (useLocation أو NavLink)

### 5. تعديل HomePage
- استبدل setPage(item.id) بـ navigate(`/${item.id}`)

### 6. تعديل الصفحات التي تستخدم setPage
هذه الصفحات تستدعي setPage وتحتاج تعديل:
- TemplatesPage: setPage('generator') → navigate('/generator')
- DraftsPage: setPage('generator') → navigate('/generator')
- GeneratorPage: إذا كان يستدعي setPage

### 7. معالجة letterType و editDraft
هذه متغيرات تُمرر بين الصفحات (Templates → Generator → Drafts). خيارات:
- **الأسهل:** استخدم state في navigate: `navigate('/generator', { state: { letterType: 'intro' } })` ثم `useLocation().state.letterType` في GeneratorPage
- أو استخدم URL params: `/generator/intro`

اختر الأسهل والأنسب.

### 8. تعديل main.jsx
لف التطبيق بـ BrowserRouter (أو HashRouter إذا كان النشر على GitHub Pages):
```jsx
import { HashRouter } from 'react-router-dom';
// HashRouter أفضل لـ GitHub Pages لأن static hosting لا يدعم SPA routing
<HashRouter>
  <App />
</HashRouter>
```

### 9. تعديل vite.config.js
إذا كان base: './' موجوداً، أبقه — مناسب لـ HashRouter.

### 10. معالجة UnsavedContext (dirty)
- تأكد أن تحذير "هل أنت متأكد من المغادرة" يعمل مع React Router
- استخدم useBlocker أو beforeunload حسب الإصدار

## التحقق:
1. npm run build — يجب أن ينجح
2. npm run dev — تأكد:
   - كل الصفحات تعمل عبر URL
   - زر "رجوع" في المتصفح يعمل
   - Sidebar يعرض الصفحة النشطة بشكل صحيح
   - التنقل من HomePage يعمل
   - تدفق الخطابات (Templates → Generator → Drafts) يعمل
3. تقرير مختصر
```

---

## الخطوة 12: إضافة Supabase — الإعداد الأساسي

```
# المهمة: إضافة Supabase — المرحلة 1: الإعداد والبنية التحتية

## ⚠️ قواعد:
- لا تكسر التطبيق الحالي — localStorage يجب أن يبقى يعمل كـ fallback
- أنشئ طبقة تجريد (abstraction layer) بحيث يمكن التبديل بين localStorage و Supabase
- بعد الانتهاء شغّل `npm run build`

## السياق:
التطبيق حالياً يخزن كل البيانات في localStorage. نريد إضافة Supabase كخيار تخزين سحابي مع:
- مصادقة (Auth) لكل مكتب
- تخزين بيانات في PostgreSQL عبر Supabase
- الإبقاء على localStorage كـ cache وللعمل بدون إنترنت

## المطلوب:

### 1. تثبيت Supabase Client
```
npm install @supabase/supabase-js
```

### 2. إنشاء ملف .env.local (لا تضفه لـ git)
```
VITE_SUPABASE_URL=YOUR_SUPABASE_URL
VITE_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
```

### 3. إنشاء .env.example (هذا يُضاف لـ git)
```
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=
```

### 4. تحديث .gitignore
أضف:
```
.env.local
.env
```

### 5. إنشاء src/core/supabase-client.js
```javascript
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// إذا لم تُعرّف المتغيرات، لا تنشئ العميل (وضع localStorage فقط)
export const supabase = (supabaseUrl && supabaseAnonKey)
  ? createClient(supabaseUrl, supabaseAnonKey)
  : null;

export const isSupabaseEnabled = () => !!supabase;
```

### 6. إنشاء src/core/storage-adapter.js
هذا هو المحور — طبقة تجريد تختار بين localStorage و Supabase:

```javascript
/**
 * Storage Adapter — يختار تلقائياً بين Supabase و localStorage
 * 
 * القاعدة:
 * - إذا Supabase متاح ومستخدم مسجّل → استخدم Supabase (مع cache في localStorage)
 * - إذا لا → استخدم localStorage فقط (السلوك الحالي)
 */

import { supabase, isSupabaseEnabled } from './supabase-client.js';
import { safeGet, safeSet } from './dataStore.js';

export const storageAdapter = {
  async get(table, filters = {}) {
    if (isSupabaseEnabled() && await isAuthenticated()) {
      // جلب من Supabase
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .match(filters);
      if (error) {
        console.error('Supabase get error:', error);
        // Fallback إلى localStorage
        return safeGet(mapTableToKey(table), []);
      }
      return data;
    }
    // localStorage فقط
    return safeGet(mapTableToKey(table), []);
  },

  async set(table, data) {
    if (isSupabaseEnabled() && await isAuthenticated()) {
      const { error } = await supabase
        .from(table)
        .upsert(data);
      if (error) {
        console.error('Supabase set error:', error);
      }
    }
    // دائماً خزّن في localStorage كـ cache
    safeSet(mapTableToKey(table), data);
  },

  // ... باقي العمليات (delete، list، إلخ)
};

function mapTableToKey(table) {
  const map = {
    transactions: 'ff_transactions',
    commissions: 'ff_commissions',
    drafts: 'ff_drafts',
    settings: 'ff_settings',
    ledgers: 'ff_ledgers',
    recurring_items: 'ff_recurring_items',
  };
  return map[table] || table;
}

async function isAuthenticated() {
  if (!supabase) return false;
  const { data: { session } } = await supabase.auth.getSession();
  return !!session;
}
```

**ملاحظة مهمة:** لا تعدّل dataStore.js في هذه المرحلة — فقط أنشئ الطبقة الجديدة. التكامل مع dataStore سيكون في خطوة لاحقة.

### 7. إنشاء src/core/supabase-schema.sql
وثّق هيكل الجداول المطلوب في Supabase:

```sql
-- جدول المكاتب (offices)
CREATE TABLE offices (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  phone TEXT,
  email TEXT,
  default_commission_percent NUMERIC DEFAULT 50,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- جدول الحركات المالية
CREATE TABLE transactions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  office_id UUID REFERENCES offices(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
  category TEXT NOT NULL,
  amount NUMERIC NOT NULL,
  payment_method TEXT,
  date DATE NOT NULL,
  description TEXT,
  ledger_id UUID,
  meta JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- جدول العمولات
CREATE TABLE commissions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  office_id UUID REFERENCES offices(id) ON DELETE CASCADE,
  client_name TEXT NOT NULL,
  deal_value NUMERIC NOT NULL,
  office_percent NUMERIC DEFAULT 0,
  agent_name TEXT,
  agent_percent NUMERIC DEFAULT 0,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'paid')),
  due_date DATE,
  paid_date DATE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- جدول الدفاتر
CREATE TABLE ledgers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  office_id UUID REFERENCES offices(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type TEXT,
  note TEXT,
  currency TEXT DEFAULT 'SAR',
  budgets JSONB DEFAULT '[]',
  income_model JSONB,
  archived BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- جدول الالتزامات المتكررة
CREATE TABLE recurring_items (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  office_id UUID REFERENCES offices(id) ON DELETE CASCADE,
  ledger_id UUID REFERENCES ledgers(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  category TEXT,
  amount NUMERIC NOT NULL,
  frequency TEXT DEFAULT 'monthly',
  next_due_date DATE,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- جدول المسودات
CREATE TABLE drafts (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  office_id UUID REFERENCES offices(id) ON DELETE CASCADE,
  template_type TEXT NOT NULL,
  fields JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Row Level Security (RLS)
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE commissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE ledgers ENABLE ROW LEVEL SECURITY;
ALTER TABLE recurring_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE drafts ENABLE ROW LEVEL SECURITY;

-- سياسة: كل مستخدم يرى بيانات مكتبه فقط
-- (يُفعّل بعد إعداد Auth)
```

### 8. لا تعدل أي ملف موجود حالياً
هذه المرحلة هي إعداد فقط. التكامل مع التطبيق الحالي سيكون في الخطوة التالية.

## التحقق:
1. npm run build — يجب أن ينجح (حتى بدون متغيرات Supabase)
2. التطبيق يجب أن يعمل بشكل طبيعي بدون Supabase (لأن isSupabaseEnabled() ستكون false)
3. تقرير مختصر: الملفات المنشأة، نتيجة البناء
```

---

## الخطوة 13: إضافة Supabase — صفحة تسجيل الدخول والمصادقة

```
# المهمة: إضافة Supabase — المرحلة 2: المصادقة وصفحة تسجيل الدخول

## ⚠️ قواعد:
- التطبيق يجب أن يعمل بدون Supabase (وضع localStorage فقط) إذا لم تُعرّف متغيرات البيئة
- لا تكسر أي وظيفة موجودة
- بعد الانتهاء شغّل `npm run build`

## المطلوب:

### 1. إنشاء src/contexts/AuthContext.jsx
```jsx
/**
 * AuthContext — يوفر حالة المصادقة للتطبيق
 * 
 * إذا Supabase غير مفعّل → المستخدم يُعتبر "محلي" دائماً (لا حاجة لتسجيل دخول)
 * إذا Supabase مفعّل → يجب تسجيل الدخول
 */
import React, { createContext, useContext, useState, useEffect } from 'react';
import { supabase, isSupabaseEnabled } from '../core/supabase-client.js';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isLocalMode, setIsLocalMode] = useState(!isSupabaseEnabled());

  useEffect(() => {
    if (!isSupabaseEnabled()) {
      setIsLocalMode(true);
      setLoading(false);
      return;
    }

    // جلب الجلسة الحالية
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // الاستماع لتغييرات المصادقة
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setUser(session?.user ?? null);
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  const signIn = async (email, password) => {
    if (!isSupabaseEnabled()) return { error: 'Supabase غير مفعّل' };
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    return { data, error };
  };

  const signUp = async (email, password, officeName) => {
    if (!isSupabaseEnabled()) return { error: 'Supabase غير مفعّل' };
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: { data: { office_name: officeName } }
    });
    return { data, error };
  };

  const signOut = async () => {
    if (!isSupabaseEnabled()) return;
    await supabase.auth.signOut();
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, loading, isLocalMode, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => useContext(AuthContext);
```

### 2. إنشاء src/pages/LoginPage.jsx
أنشئ صفحة تسجيل دخول بسيطة وأنيقة:
- تصميم يتوافق مع ثيم التطبيق (RTL، عربي، نفس الألوان والخطوط)
- حقول: البريد الإلكتروني، كلمة المرور
- أزرار: تسجيل الدخول، إنشاء حساب جديد
- عند إنشاء حساب: حقل إضافي لاسم المكتب
- معالجة أخطاء (بريد خاطئ، كلمة مرور قصيرة، حساب موجود، إلخ)
- عرض رسائل Toast عند الخطأ
- بعد تسجيل الدخول بنجاح: توجيه إلى الصفحة الرئيسية
- زر "استخدام بدون حساب (محلي)" — يتخطى تسجيل الدخول ويستخدم localStorage فقط

### 3. تعديل App.jsx
- استورد AuthProvider ولف التطبيق بها
- إذا isSupabaseEnabled() وليس هناك user مسجّل → اعرض LoginPage
- إذا isLocalMode أو هناك user → اعرض التطبيق العادي
- أضف زر "تسجيل خروج" في SettingsPage أو Sidebar (فقط إذا Supabase مفعّل)

### 4. تعديل main.jsx
```jsx
import { AuthProvider } from './contexts/AuthContext.jsx';

// داخل render:
<AuthProvider>
  <HashRouter>
    <App />
  </HashRouter>
</AuthProvider>
```

## التحقق:
1. npm run build — يجب أن ينجح
2. بدون متغيرات Supabase → التطبيق يعمل بشكل طبيعي (localStorage فقط)
3. تقرير مختصر
```

---

## الخطوة 14: إضافة Supabase — تكامل dataStore مع Supabase

```
# المهمة: إضافة Supabase — المرحلة 3: تكامل dataStore مع Supabase

## ⚠️ قواعد:
- localStorage يبقى يعمل كـ fallback وcache دائماً
- أي خطأ في Supabase يجب أن يُعالج بصمت مع fallback إلى localStorage
- لا تكسر أي وظيفة موجودة
- بعد الانتهاء شغّل `npm run build`

## السياق:
- src/core/dataStore.js يحتوي على safeGet/safeSet/createCrud/dataStore
- src/core/storage-adapter.js (أنشئ في الخطوة 12) يحتوي على طبقة التجريد
- src/contexts/AuthContext.jsx يوفر معلومات المستخدم

## المطلوب:

### 1. تعديل src/core/dataStore.js
أضف دعم Supabase مع الحفاظ على التوافق الكامل مع localStorage:

لكل عملية في dataStore (مثل transactions.list، transactions.create، إلخ):
- إذا Supabase مفعّل ومستخدم مسجّل:
  - اقرأ من Supabase أولاً
  - خزّن نسخة في localStorage كـ cache
  - عند الكتابة: اكتب في Supabase + localStorage معاً
  - عند فشل Supabase: استخدم localStorage وسجّل الخطأ
- إذا Supabase غير مفعّل أو لا مستخدم:
  - استخدم localStorage فقط (السلوك الحالي بالضبط)

### 2. المنهج المقترح
بدلاً من تعديل كل دالة في dataStore، أنشئ wrapper:

```javascript
// في dataStore.js

import { supabase, isSupabaseEnabled } from './supabase-client.js';

// دالة مساعدة: هل نستخدم Supabase؟
async function useCloud() {
  if (!isSupabaseEnabled()) return false;
  const { data: { session } } = await supabase.auth.getSession();
  return !!session;
}

// تحديث createCrud ليدعم Supabase:
function createCrud(localKey, supabaseTable) {
  return {
    list: async (filterFn) => {
      if (await useCloud()) {
        try {
          const { data, error } = await supabase.from(supabaseTable).select('*');
          if (!error && data) {
            safeSet(localKey, data); // cache محلي
            return filterFn ? data.filter(filterFn) : data;
          }
        } catch (e) {
          console.error(`Supabase ${supabaseTable} list error:`, e);
        }
      }
      // fallback إلى localStorage
      const items = safeGet(localKey, []);
      return filterFn ? items.filter(filterFn) : items;
    },
    
    create: async (item) => {
      const enriched = { ...item, id: item.id || genId(), createdAt: now(), updatedAt: now() };
      if (await useCloud()) {
        try {
          await supabase.from(supabaseTable).insert(enriched);
        } catch (e) {
          console.error(`Supabase ${supabaseTable} create error:`, e);
        }
      }
      // دائماً خزّن محلياً
      const items = safeGet(localKey, []);
      items.push(enriched);
      safeSet(localKey, items);
      return enriched;
    },
    
    // ... نفس المنهج لـ update و remove
  };
}
```

### 3. ملاحظة مهمة عن الـ async
- dataStore الحالي synchronous (يستخدم safeGet/safeSet مباشرة)
- إضافة Supabase تتطلب async/await
- هذا يعني أن كل الصفحات التي تستدعي dataStore.transactions.list() مثلاً ستحتاج تعديل
- **الحل الأسهل:** اجعل الدوال async لكن في وضع localStorage فقط تُرجع البيانات فوراً (لا await فعلي)
- أو استخدم pattern مثل: `useEffect(() => { dataStore.transactions.list().then(setItems); }, [])`

### 4. تعديل الصفحات لدعم async
عدّل كل صفحة تستدعي dataStore:
- استخدم useEffect + useState لجلب البيانات
- أضف حالة loading أثناء الجلب
- أضف معالجة أخطاء

**ملاحظة:** هذا تغيير كبير. إذا وجدت أنه معقد جداً، يمكنك بدلاً من ذلك:
- إنشاء hook مثل `useDataStore(table)` يُعيد `{ data, loading, error, refresh, create, update, remove }`
- استخدامه في كل الصفحات بدل الاستدعاء المباشر لـ dataStore

اختر الطريقة الأنسب والأكثر أماناً.

## التحقق:
1. npm run build
2. بدون Supabase → كل شيء يعمل كما قبل
3. تقرير مختصر يشمل: ما تم تعديله، المنهج المُتبع، أي تحذيرات
```

---

## الخطوة 15: إضافة اختبارات Vitest للمنطق المالي

```
# المهمة: إضافة اختبارات Vitest للمنطق المالي الحساس

## ⚠️ قواعد:
- لا تعدل أي كود موجود — فقط أضف ملفات اختبار
- بعد الانتهاء شغّل `npm run build` و `npm test`

## المطلوب:

### 1. تثبيت Vitest
```
npm install -D vitest
```

### 2. تحديث package.json
```json
"scripts": {
  "test": "vitest run",
  "test:watch": "vitest"
}
```

### 3. إنشاء vitest.config.js (إذا لزم)
أو أضف في vite.config.js:
```javascript
/// <reference types="vitest" />
export default defineConfig({
  // ... الإعدادات الحالية
  test: {
    globals: true,
    environment: 'jsdom',
  },
});
```

### 4. إنشاء الاختبارات

#### src/__tests__/helpers.test.js
اختبر:
- genId: يولد معرفات فريدة
- today: يرجع تاريخ بصيغة YYYY-MM-DD
- isValidDateStr: يقبل تواريخ صحيحة ويرفض الخاطئة (مثل 2025-99-99، 2025-02-30، null، undefined، '')
- safeNum: يحوّل أرقام صحيحة ويرجع fallback للقيم الخاطئة (NaN، undefined، 'abc')

#### src/__tests__/format.test.js
اختبر:
- formatNumber: تنسيق أرقام مع كسور عشرية
- formatCurrency: تنسيق مبلغ بعملة (ر.س)
- formatPercent: تنسيق نسبة مئوية
- تأكد من معالجة القيم الحدية (0، سالب، كبير جداً، undefined)

#### src/__tests__/dataStore.test.js
اختبر (مع mock لـ localStorage):
- safeGet: قراءة مفتاح موجود، مفتاح غير موجود، JSON تالف
- safeSet: كتابة عادية، كتابة تتجاوز Quota (mock QuotaExceededError)
- createCrud: إنشاء عنصر، قراءة قائمة، تحديث، حذف

#### src/__tests__/domain-transactions.test.js
اختبر الدوال في src/domain/transactions.js:
- فلترة الحركات بنوع (دخل/خرج)
- فلترة بتصنيف
- فلترة بتاريخ
- حساب الإجمالي

#### src/__tests__/domain-commissions.test.js
اختبر:
- filterCommissions: بحالة (معلقة/مدفوعة)
- computeCommissionTotals: حساب إجمالي العمولات
- listAgentNames: استخراج أسماء الوكلاء

#### src/__tests__/dateFormat.test.js
اختبر:
- formatDateGregorianNumeric: تاريخ ميلادي صحيح
- isValidDateStr (إذا لم يُختبر في helpers): حالات حدية

### 5. هدف التغطية
- لا نحتاج تغطية 100% — ركّز على المنطق المالي الحساس
- الأهم: الحسابات، التحقق من المدخلات، تحويل البيانات

## التحقق:
1. npm run build — يجب أن ينجح
2. npm test — يجب أن تنجح كل الاختبارات
3. تقرير: عدد الاختبارات، كم نجح، كم فشل، أي ملاحظات
```

---

## ملخص كل الخطوات

| الخطوة | المحتوى | الحالة |
|--------|---------|--------|
| 1-9 | تقسيم App.jsx | ✅ تمت |
| 10 | إصلاح Chart bug + تنظيف ملفات | ⏳ التالية |
| 11 | React Router | ⏳ |
| 12 | Supabase — إعداد أساسي | ⏳ |
| 13 | Supabase — Auth وتسجيل دخول | ⏳ |
| 14 | Supabase — تكامل dataStore | ⏳ |
| 15 | اختبارات Vitest | ⏳ |

ابدأ بالخطوة 10 وكمّل بالترتيب. كل خطوة تنتهي بـ `npm run build` ناجح قبل الانتقال للتالية. إذا واجهت مشكلة اخبرني بالمشكلة والحل المقترح

---

*بعد أن تملأ المحتوى أعلاه، قل لي: "اطلع على ملف طلبات-إصلاحات.md ونفّذ المطلوب".*
